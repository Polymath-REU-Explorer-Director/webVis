// Generated by CoffeeScript 1.12.8
var ExplorerDirector, chooseRandom, getRandomInt,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

getRandomInt = function(max) {
  return Math.floor(Math.random() * Math.floor(max));
};

chooseRandom = function(list, startIndex) {
  var index;
  if (startIndex == null) {
    startIndex = 0;
  }
  index = getRandomInt(list.length - startIndex) + startIndex;
  return list[index];
};

ExplorerDirector = (function() {
  var BORDER_COLOR, CURRENT_COLOR, TOKEN_COLOR, UNVISITED_COLOR, VISITED_COLOR, VISIT_COLOR;

  function ExplorerDirector(graph, network, tokenID1) {
    this.graph = graph != null ? graph : new Graph();
    this.network = network;
    this.tokenID = tokenID1;
    if (this.tokenID == null) {
      this.tokenID = this.graph.vertices()[0];
    }
    this.visitedList = [this.tokenID];
  }

  ExplorerDirector.prototype.hasBeenVisited = function(vertex) {
    return this.visitedList.indexOf(vertex) !== -1;
  };

  UNVISITED_COLOR = "white";

  VISITED_COLOR = "yellow";

  CURRENT_COLOR = TOKEN_COLOR = "limegreen";

  BORDER_COLOR = "black";

  VISIT_COLOR = "red";

  ExplorerDirector.prototype.updateGraph = function() {
    var edge, i, j, len, len1, node, ref, ref1;
    this.graph.clear();
    ref = this.network.body.data.nodes.get();
    for (i = 0, len = ref.length; i < len; i++) {
      node = ref[i];
      this.graph.addVertex(node.id);
    }
    ref1 = this.network.body.data.edges.get();
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      edge = ref1[j];
      this.graph.addEdge(edge.from, edge.to);
    }
    if (this.graph.adjList[this.tokenID] == null) {
      this.tokenID = Object.keys(this.graph.adjList)[0];
      if (!this.hasBeenVisited(this.tokenID)) {
        this.visitedList.push(this.tokenID);
      }
      return this.setBackgroundColor(this.tokenID, CURRENT_COLOR);
    }
  };

  ExplorerDirector.prototype.setBorderColor = function(nodeID, color) {
    var node;
    node = this.network.body.data.nodes.get(nodeID);
    if (node.x != null) {
      delete node.x;
    }
    if (node.y != null) {
      delete node.y;
    }
    if (node.color == null) {
      node.color = {};
    }
    node.color.border = color;
    return this.network.body.data.nodes.update(node);
  };

  ExplorerDirector.prototype.setBackgroundColor = function(nodeID, color) {
    var node;
    node = this.network.body.data.nodes.get(nodeID);
    if (node.x != null) {
      delete node.x;
    }
    if (node.y != null) {
      delete node.y;
    }
    if (node.color == null) {
      node.color = {};
    }
    node.color.background = color;
    return this.network.body.data.nodes.update(node);
  };

  ExplorerDirector.prototype.recolorUnvisitedNodes = function() {
    var i, len, node, ref, ref1, results;
    ref = this.network.body.data.nodes.get();
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      node = ref[i];
      if (node.color == null) {
        results.push(node.color = {});
      } else if (!(node.id === this.tokenID || (ref1 = node.id, indexOf.call(this.visitedList, ref1) >= 0))) {
        results.push(this.setBackgroundColor(node.id, UNVISITED_COLOR));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  ExplorerDirector.prototype.defaultBorderColor = function() {
    var i, len, ref, results, vertex;
    ref = this.graph.vertices();
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      vertex = ref[i];
      results.push(this.setBorderColor(vertex, BORDER_COLOR));
    }
    return results;
  };

  ExplorerDirector.prototype.getDistInput = function() {
    var distance;
    distance = parseInt(document.getElementById("distInput").value);
    if (isNaN(distance) || !(distance > 0)) {
      alert("Error: distance must be a positive integer");
    }
    return distance;
  };

  ExplorerDirector.prototype.seePossibleMoves = function(startVertex) {
    var distance, i, len, results, v, vertices;
    if (startVertex == null) {
      startVertex = this.tokenID;
    }
    ed.updateGraph();
    this.defaultBorderColor();
    distance = this.getDistInput();
    vertices = this.canMoveList(startVertex, distance);
    results = [];
    for (i = 0, len = vertices.length; i < len; i++) {
      v = vertices[i];
      results.push(this.setBorderColor(v, VISIT_COLOR));
    }
    return results;
  };

  ExplorerDirector.prototype.newGame = function() {
    var vertex;
    ed.updateGraph();
    for (vertex in this.graph.adjList) {
      this.setBackgroundColor(vertex, UNVISITED_COLOR);
    }
    this.setBackgroundColor(this.tokenID, TOKEN_COLOR);
    this.visitedList = [this.tokenID];
    return document.getElementById("gameWon").innerHTML = "";
  };

  ExplorerDirector.prototype.canMoveList = function(vertex, distance) {
    var ans, distances, v;
    distances = this.graph.distMatrix[vertex];
    ans = [];
    for (v in distances) {
      if (distances[v] === distance) {
        ans.push(v);
      }
    }
    return ans;
  };

  ExplorerDirector.prototype.moveToken = function(dest, inGame) {
    if (inGame == null) {
      inGame = false;
    }
    ed.updateGraph();
    if (inGame) {
      this.setBackgroundColor(this.tokenID, VISITED_COLOR);
    } else {
      this.setBackgroundColor(this.tokenID, UNVISITED_COLOR);
      this.newGame();
    }
    this.tokenID = dest;
    if (!this.hasBeenVisited(this.tokenID)) {
      this.visitedList.push(this.tokenID);
    }
    this.setBackgroundColor(dest, CURRENT_COLOR);
    if (this.gameFinished()) {
      return document.getElementById("gameWon").innerHTML = "Game Over";
    } else {
      return document.getElementById("gameWon").innerHTML = "";
    }
  };

  ExplorerDirector.prototype.directorMoveRandom = function(basicLogic) {
    var destination, distance, i, len, vertex, vertices;
    if (basicLogic == null) {
      basicLogic = false;
    }
    ed.updateGraph();
    this.defaultBorderColor();
    distance = this.getDistInput();
    vertices = this.canMoveList(this.tokenID, distance);
    if (vertices.length === 0 || (vertices.length == null)) {
      throw "Invalid distance";
    }
    destination = chooseRandom(vertices);
    if (basicLogic) {
      for (i = 0, len = vertices.length; i < len; i++) {
        vertex = vertices[i];
        if (this.hasBeenVisited(vertex)) {
          destination = vertex;
        }
      }
    }
    return this.moveToken(destination, true);
  };

  ExplorerDirector.prototype.explorerChooseRandom = function(basicLogic) {
    var currentDist, distance, distances, options, vertex;
    if (basicLogic == null) {
      basicLogic = false;
    }
    ed.updateGraph();
    this.defaultBorderColor();
    distances = this.graph.distances(this.tokenID);
    options = [];
    for (vertex in distances) {
      currentDist = distances[vertex];
      if (currentDist !== 0) {
        if (options.indexOf(currentDist) === -1) {
          options.push(currentDist);
        }
      }
    }
    distance = chooseRandom(options);
    return distance;
  };

  ExplorerDirector.prototype.canForceNode = function(nodesVisited, tokenPos) {
    var canForce, dist, distances, i, index, len, moveList, ref, ref1;
    if (nodesVisited == null) {
      nodesVisited = this.visitedList;
    }
    if (tokenPos == null) {
      tokenPos = this.tokenID;
    }
    distances = this.graph.distMatrix[tokenPos];
    ref = Object.values(distances);
    for (i = 0, len = ref.length; i < len; i++) {
      dist = ref[i];
      if (dist !== 0) {
        moveList = this.canMoveList(tokenPos, dist, distances);
        canForce = true;
        index = 0;
        while (index < moveList.length && canForce) {
          if (ref1 = moveList[index], indexOf.call(nodesVisited, ref1) >= 0) {
            canForce = false;
          }
          index++;
        }
        if (canForce) {
          return true;
        }
      }
    }
    return false;
  };

  ExplorerDirector.prototype.gameFinished = function(nodesVisited, tokenPos) {
    var i, len, node;
    if (nodesVisited == null) {
      nodesVisited = this.visitedList.slice();
    }
    if (tokenPos == null) {
      tokenPos = this.tokenID;
    }
    if (this.canForceNode(nodesVisited, tokenPos)) {
      return false;
    }
    for (i = 0, len = nodesVisited.length; i < len; i++) {
      node = nodesVisited[i];
      if (node !== tokenPos && this.canForceNode(nodesVisited, node)) {
        nodesVisited.splice(nodesVisited.indexOf(node), 1);
        return this.gameFinished(nodesVisited, tokenPos);
      }
    }
    return true;
  };

  ExplorerDirector.prototype.minimax = function(nodesVisited, tokenID, expChoice, maxDepth, maxPlayer) {
    var dist, distances, i, j, len, len1, node, ref, ref1, value;
    if (expChoice == null) {
      expChoice = 0;
    }
    if (maxDepth === 0) {
      return (new Set(nodesVisited)).size;
    }
    if (maxPlayer && this.gameFinished(nodesVisited.slice(), tokenID)) {
      return (new Set(nodesVisited)).size;
    }
    if (maxPlayer) {
      value = -2e308;
      distances = this.graph.distMatrix[tokenID];
      ref = Object.values(distances);
      for (i = 0, len = ref.length; i < len; i++) {
        dist = ref[i];
        value = Math.max(value, this.minimax(nodesVisited, tokenID, dist, maxDepth - 1, false));
      }
      return value;
    } else {
      value = 2e308;
      ref1 = this.canMoveList(tokenID, expChoice);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        node = ref1[j];
        nodesVisited.push(node);
        value = Math.min(value, this.minimax(nodesVisited, node, expChoice, maxDepth - 1, true));
        nodesVisited.pop();
      }
      return value;
    }
  };

  return ExplorerDirector;

})();
